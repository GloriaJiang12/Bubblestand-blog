(window.webpackJsonp=window.webpackJsonp||[]).push([[22],{505:function(t,r,_){"use strict";_.r(r);var s=_(4),v=Object(s.a)({},(function(){var t=this,r=t.$createElement,_=t._self._c||r;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h1",{attrs:{id:"js"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#js"}},[t._v("#")]),t._v(" js")]),t._v(" "),_("h2",{attrs:{id:"js执行机制-宏任务-微任务是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#js执行机制-宏任务-微任务是什么"}},[t._v("#")]),t._v(" js执行机制，宏任务，微任务是什么？")]),t._v(" "),_("p",[_("strong",[t._v("任务队列：")]),_("br"),t._v("\n 1、js分同步和异步"),_("br"),t._v("\n 2、同步任务都会在主线程上执行，形成一个执行栈"),_("br"),t._v("\n 3、主线程之外，事件触发线程管理者一个任务队列，放置异步事件"),_("br"),t._v("\n 4、一旦执行栈执行完所有同步任务就会读取任务队列，把异步任务取出来放置在执行栈中执行"),_("br"),t._v(" "),_("strong",[t._v("Event Loop：")]),_("br"),t._v("\n 事件循环是通过任务队列的机制来进行协调的。一个 Event Loop 中，可以有一个或者多个任务队列(task queue)，一个任务队列便是一系列有序任务(task)的集合；每个任务都有一个任务源(task source)，源自同一个任务源的 task 必须放到同一个任务队列，从不同源来的则被添加到不同队列。 setTimeout/Promise 等API便是任务源，而进入任务队列的是他们指定的具体执行任务"),_("br"),t._v(" "),_("strong",[t._v("宏任务：")]),_("br"),t._v("\n 每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）。宏任务包括\nscript(整体代码)、setTimeout、setInterval"),_("br"),t._v(" "),_("strong",[t._v("微任务：")]),_("br"),t._v("\n 在当前 task 执行结束后立即执行的任务。微任务包括promise.then"),_("br"),t._v(" "),_("strong",[t._v("js运行机制：")]),_("br"),t._v("\n 1、执行一个宏任务（栈中没有就从事件队列中获取）"),_("br"),t._v("\n 2、执行过程中如果遇到微任务，就将它添加到微任务的任务队列中"),_("br"),t._v("\n 3、宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）"),_("br"),t._v("\n 4、当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染"),_("br"),t._v("\n 5、渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）"),_("br"),t._v(" "),_("strong",[t._v("await:")]),_("br"),t._v("\n 实际上await是一个让出线程的标志。await后面的表达式会先执行一遍，将await后面的代码加入到microtask中，然后就会跳出整个async函数来执行后面的代码。")]),t._v(" "),_("h2",{attrs:{id:"作用域"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#作用域"}},[t._v("#")]),t._v(" 作用域")]),t._v(" "),_("ul",[_("li",[t._v("就是代码的执行环境。执行环境定义了变量或函数有权去访问其他数据。分为两种：全局作用域和函数作用域。")]),t._v(" "),_("li",[t._v("全局作用域只能访问全局环境的变量和方法；函数作用域是在函数中定义的变量、属性和方法只能在当前函数中访问。")]),t._v(" "),_("li",[t._v("在web浏览器中，全局环境被认为是window对象，因此所有的全局变量和函数都是作为window对象的属性和方法创建的；在node环境中，全局执行环境是global")]),t._v(" "),_("li",[t._v("当某个执行环境的代码执行完毕之后，该环境会被销毁，随之该环境的变量和方法也会被销毁；全局执行环境是直到退出应用程序，比如关闭网页等才会被销毁")])]),t._v(" "),_("h2",{attrs:{id:"作用域链"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#作用域链"}},[t._v("#")]),t._v(" 作用域链")]),t._v(" "),_("ul",[_("li",[t._v("当一个变量或函数在定义的时候，就会创建一个作用域链，这个作用域链，其实就是作用域形成的一个链条一样，它定义了当前环境如何去访问变量和函数")]),t._v(" "),_("li",[t._v("内部函数可以通过作用域链去访问外部环境，但是外部环境不能访问内部环境")]),t._v(" "),_("li",[t._v("假设在一个私有函数中我们使用一个变量。代码执行时我们会先从当前作用域查找是否有该变量，如果没有就会到全局环境中查找")])]),t._v(" "),_("h2",{attrs:{id:"原型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#原型"}},[t._v("#")]),t._v(" 原型")]),t._v(" "),_("ul",[_("li",[t._v("js为所有函数提供了一个属性prototype，也就是原型，该属性是一个对象，用于保存函数实例的公有属性和方法")]),t._v(" "),_("li",[t._v("而每个原型里面都有一个constructor属性，该属性是一个指针，用于指向该原型所在的函数")]),t._v(" "),_("li",[t._v("js中所有引用类型（对象）都有一个隐式原型__proto__，它是一个指针，指向当前构造函数的原型。隐式原型是用来构成原型链，实现基于原型链的继承")])]),t._v(" "),_("h2",{attrs:{id:"原型链"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#原型链"}},[t._v("#")]),t._v(" 原型链")]),t._v(" "),_("ul",[_("li",[t._v("就是原型对象创建的过程记录。当一个对象需要调用一个属性的时候，首先会从自身属性上查找，如果没有找到，就会去隐式原型__proto__上查找，也就是它的构造函数的原型prototype上查找，如果还没有找到，就会从构造函数的原型prototype的隐式原型__proto__上查找；如果找到出口还没找到，也就是Object的原型的隐式原型，就返回undefined,原型链就是这样一层一层向上查找形成的一个链式结构。")])])])}),[],!1,null,null,null);r.default=v.exports}}]);